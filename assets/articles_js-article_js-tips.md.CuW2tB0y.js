import{_ as s,c as a,o as l,a3 as e}from"./chunks/framework.BSW09o0Z.js";const c=JSON.parse('{"title":"JavaScript 技巧","description":"","frontmatter":{},"headers":[],"relativePath":"articles/js-article/js-tips.md","filePath":"articles/js-article/js-tips.md"}'),t={name:"articles/js-article/js-tips.md"};function n(p,i,h,o,k,d){return l(),a("div",null,i[0]||(i[0]=[e(`<h1 id="javascript-技巧" tabindex="-1">JavaScript 技巧 <a class="header-anchor" href="#javascript-技巧" aria-label="Permalink to &quot;JavaScript 技巧&quot;">​</a></h1><h2 id="一、为什么typeof-的返回值是-object" tabindex="-1">一、为什么<code>typeof []</code> 的返回值是 <code>&quot;object&quot;</code> <a class="header-anchor" href="#一、为什么typeof-的返回值是-object" aria-label="Permalink to &quot;一、为什么\`typeof []\` 的返回值是 \`&quot;object&quot;\`&quot;">​</a></h2><h3 id="历史原因" tabindex="-1">历史原因 <a class="header-anchor" href="#历史原因" aria-label="Permalink to &quot;历史原因&quot;">​</a></h3><p>JavaScript 最初设计时开发周期较短，语言的类型系统设计相对简单。在早期版本中，JavaScript 只有少数几种基本数据类型（如 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>），而其他所有非基本数据类型的值都被归类为 <code>object</code>。数组在 JavaScript 中属于复合数据类型，并非基本数据类型，因此按照当时的设计逻辑，<code>typeof</code> 运算符对数组返回 <code>&quot;object&quot;</code>。</p><h3 id="底层实现机制" tabindex="-1">底层实现机制 <a class="header-anchor" href="#底层实现机制" aria-label="Permalink to &quot;底层实现机制&quot;">​</a></h3><p>JavaScript 中的值在底层以二进制形式存储，每个值都有一个类型标签来表示其类型。在 JavaScript 引擎内部，类型标签是一个很小的整数，用于标识值的类型。对于大多数对象（包括数组），类型标签表示的就是对象类型。<code>typeof</code> 运算符是根据这个类型标签来判断值的类型的，由于数组的类型标签和普通对象一样被标记为对象类型，所以 <code>typeof []</code> 返回 <code>&quot;object&quot;</code>。</p><h3 id="示例代码验证" tabindex="-1">示例代码验证 <a class="header-anchor" href="#示例代码验证" aria-label="Permalink to &quot;示例代码验证&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: &quot;object&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: &quot;object&quot;</span></span></code></pre></div><h3 id="如何准确判断数组类型" tabindex="-1">如何准确判断数组类型 <a class="header-anchor" href="#如何准确判断数组类型" aria-label="Permalink to &quot;如何准确判断数组类型&quot;">​</a></h3><p>由于 <code>typeof</code> 无法准确区分数组和普通对象，你可以使用以下几种方法来判断一个值是否为数组：</p><ul><li><strong><code>Array.isArray()</code> 方法</strong>：这是 ES5 引入的方法，专门用于判断一个值是否为数组，使用起来简单直接。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: true</span></span></code></pre></div><ul><li><strong><code>instanceof</code> 运算符</strong>：用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。 <strong>虽然通常可用,但在多框架环境下可能失效,因为 Array 构造函数可能来自不同的执行上下文。另外,如果修改了对象的原型链,这个方法也会失效。</strong></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: true</span></span></code></pre></div><ul><li><strong><code>Object.prototype.toString.call()</code> 方法</strong>：可以返回一个表示对象类型的字符串，通过判断该字符串是否为 <code>[object Array]</code> 来确定是否为数组。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;[object Array]&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: true</span></span></code></pre></div><h2 id="二、tostring" tabindex="-1">二、toString() <a class="header-anchor" href="#二、tostring" aria-label="Permalink to &quot;二、toString()&quot;">​</a></h2><ol><li><code>toString()</code> 方法用于将一个对象转换为字符串。</li><li><code>2.toString()</code> 会导致语法错误,因为 JavaScript 解析器会将点号优先识别为小数点，而不是对象属性访问符，所以会报语法错误。</li><li><code>2..toString()</code> 第一个点号被解析为小数点，第二个点号被正确解析为对象属性访问符。这种写法虽然看起来怪异，但在 JavaScript 中是完全有效的语法。</li><li><code>2 .toString()</code> 通过在数字和点号之间添加空格，可以帮助 JavaScript 解析器正确理解这是一个方法调用而不是小数点。这种写法语法正确且清晰。</li><li><code>(2).toString()</code>使用括号将数字括起来，可以明确地将其转换为对象，然后调用 toString()方法。这是最常用和最清晰的写法。</li></ol><ul><li>开发中推荐使用 D 的写法，因为它最清晰易懂。</li></ul><h2 id="三、window-open" tabindex="-1">三、window.open <a class="header-anchor" href="#三、window-open" aria-label="Permalink to &quot;三、window.open&quot;">​</a></h2><ol><li><code>window.open()</code> 方法用于在浏览器中打开一个新的窗口或标签页。</li><li><code>window.open()</code> 方法的第一个参数是要打开的 URL，第二个参数是窗口名称，第三个参数是窗口特性。</li><li><code>window.open()</code> 方法返回一个对新打开窗口的引用，如果浏览器不允许弹出窗口，则返回 <code>null</code>。</li><li><code>window.open()</code> 方法的行为可能会受到浏览器的弹出窗口拦截器的影响，因此在某些情况下可能无法打开新窗口。</li><li>调用 window.open 方法以后，远程 URL 不会被立即载入，载入过程是异步的。</li></ol><h2 id="四、js-数字在计算机内存中占用多少-byte" tabindex="-1">四、JS 数字在计算机内存中占用多少 Byte <a class="header-anchor" href="#四、js-数字在计算机内存中占用多少-byte" aria-label="Permalink to &quot;四、JS 数字在计算机内存中占用多少 Byte&quot;">​</a></h2><p><strong>8 个 Byte 4 个字节</strong> 这是因为 JavaScript 遵循 IEEE 754 标准,使用双精度浮点数来表示所有数值类型。在这个格式中:</p><ul><li>1 位用于符号(正负)</li><li>11 位用于指数</li><li>52 位用于小数部分(尾数) 总共 64 位,也就是 8 字节。</li></ul><h2 id="五、js-中的运算符优先级" tabindex="-1">五、js 中的运算符优先级 <a class="header-anchor" href="#五、js-中的运算符优先级" aria-label="Permalink to &quot;五、js 中的运算符优先级&quot;">​</a></h2><ol><li>成员访问和计算属性</li></ol><p><code>.</code>（点操作符）</p><p><code>[]</code>（计算属性）</p><p><code>new</code>（创建实例）</p><p><code>()</code>（函数调用）</p><p><code>new.target</code>（在构造函数中使用）</p><ol start="2"><li>新的运算符（ES6+）</li></ol><p><code>...</code>（展开运算符）</p><p><code>super</code>（调用父类的构造函数）</p><ol start="3"><li>递增和递减</li></ol><p><code>++</code>（递增）</p><p><code>--</code>（递减）</p><ol start="4"><li>一元运算符</li></ol><p><code>delete</code></p><p><code>void</code></p><p><code>typeof</code></p><p><code>+</code>（一元加）</p><p><code>-</code>（一元减）</p><p><code>~</code>（位非）</p><p><code>!</code>（逻辑非）</p><ol start="5"><li>乘法、除法和取模</li></ol><p><code>\\*</code>（乘法）</p><p><code>/</code>（除法）</p><p><code>%</code>（取模）</p><ol><li>加法和减法</li></ol><p><code>+</code>（加法）</p><p><code>-</code>（减法）</p><ol><li>小于、大于和相等比较</li></ol><p><code>&lt;</code>（小于）</p><p><code>&gt;</code> （大于）</p><p><code>&lt;=</code>（小于等于）</p><p><code>&gt;=</code>（大于等于）</p><p><code>in</code>（属性存在）</p><p><code>instanceof</code>（实例检查）</p><ol start="8"><li>等号</li></ol><p><code>==</code>（等于）</p><p><code>!=</code>（不等于）</p><p><code>===</code>（严格等于）</p><p><code>!==</code>（严格不等于）</p><ol start="9"><li>按位与</li></ol><p><code>&amp;</code>（按位与）</p><ol start="10"><li>按位异或</li></ol><p><code>^</code>（按位异或）</p><ol start="11"><li>按位或</li></ol><p><code>|</code>（按位或）</p><ol start="12"><li>逻辑与</li></ol><p><code>&amp;&amp;</code>（逻辑与）</p><ol start="13"><li>逻辑或</li></ol><p><code>||</code>（逻辑或）</p><ol start="14"><li>可选链（ES2020+）</li></ol><p><code>?.</code>（可选链操作符）</p><ol start="15"><li>空值合并运算符（ES2020+）</li></ol><p><code>??</code>（空值合并操作符）</p><ol start="16"><li>条件（三元）运算符</li></ol><p><code>?:</code>（条件运算符）</p><ol start="17"><li>赋值运算符</li></ol><p><code>=</code>（赋值）</p><p><code>+=</code>、<code>-=</code>、<code>\\*=</code>、<code>/=</code>、<code>%=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、<code>|=</code>等复合赋值运算符。</p><ol start="18"><li>逗号运算符</li></ol><p><code>,</code>（逗号运算符，通常用于分隔多个表达式在单个语句中执行，但优先级最低，因为它主要用于分隔表达式而不是控制运算顺序。）</p><h2 id="六、sessionstorage、localstorage、cookie" tabindex="-1">六、sessionStorage、localStorage、cookie <a class="header-anchor" href="#六、sessionstorage、localstorage、cookie" aria-label="Permalink to &quot;六、sessionStorage、localStorage、cookie&quot;">​</a></h2><ol><li><p>存储容量：</p><ul><li><code>cookie</code>：每个 cookie 大小限制在 4KB 左右，浏览器对每个域名的 cookie 数量有限制（通常是 20 个）。</li><li><code>sessionStorage</code>：每个域名的存储容量通常在 5MB 到 10MB 之间。</li><li><code>localStorage</code>：每个域名的存储容量通常在 5MB 到 10MB 之间。</li></ul></li><li><p>存储方式：<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code> 都是键值对存储，但存储方式不同。</p></li><li><p>存储时间：<code>localStorage</code>的数据会永久保存,<code>sessionStorage</code>的数据在页面关闭后失效,<code>cookie</code>的数据在浏览器关闭后失效。</p></li><li><p>三者都受同源策略限制,不能跨域访问</p></li></ol><h2 id="七、export-命令" tabindex="-1">七、export 命令 <a class="header-anchor" href="#七、export-命令" aria-label="Permalink to &quot;七、export 命令&quot;">​</a></h2><ol><li>export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</li><li>export 命令必须提供对外的接口，其他脚本才可以通过这个接口，取到对应的值，本质上是在接口名与模块内部变量之间，建立了一一对应的关系</li></ol><h2 id="八、选择题" tabindex="-1">八、选择题 <a class="header-anchor" href="#八、选择题" aria-label="Permalink to &quot;八、选择题&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i)；</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 答案: 3,3,3</span></span></code></pre></div><ul><li>详细分析过程如下:</li></ul><ol><li>for 循环创建了 3 个 setTimeout 任务,每个任务都包含一个回调函数</li><li>这些回调函数都共享同一个变量 i,因为 var 声明的是函数作用域变量</li><li>当 setTimeout 的回调函数真正执行时,循环已经完成,此时 i 的值已经变成 3</li><li>所以三个回调函数执行时读取到的都是同一个 i 的值,即 3</li></ol><ul><li>如果想要实现 0,1,2 的输出,可以:</li></ul><ol><li>使用 let 代替 var 声明 i</li><li>使用闭包保存每次循环时 i 的值</li><li>将 i 作为参数传入立即执行函数</li></ol><h2 id="九、选择题" tabindex="-1">九、选择题 <a class="header-anchor" href="#九、选择题" aria-label="Permalink to &quot;九、选择题&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> print</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fn);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 答案：200</span></span></code></pre></div><ul><li>关于闭包和作用域的理解，自由变量的查找是在函数定义的地方，向上级查找，而不是在执行的地方</li></ul><h2 id="十、静态方法和实例方法" tabindex="-1">十、静态方法和实例方法 <a class="header-anchor" href="#十、静态方法和实例方法" aria-label="Permalink to &quot;十、静态方法和实例方法&quot;">​</a></h2><ol><li>静态方法：属于类本身的方法，可以直接通过类名调用，不需要实例化对象。</li><li>实例方法：属于实例对象的方法，需要通过实例对象调用。</li><li>区别：</li></ol><ul><li>静态方法通过类名调用</li><li>实例方法通过实例调用</li><li>静态方法中的 this 指向类本身</li><li>实例方法中的 this 指向实例对象</li></ul><h2 id="十一、阻止浏览器默认行为" tabindex="-1">十一、阻止浏览器默认行为 <a class="header-anchor" href="#十一、阻止浏览器默认行为" aria-label="Permalink to &quot;十一、阻止浏览器默认行为&quot;">​</a></h2><ul><li>在现代浏览器中,推荐使用<code>event.preventDefault()</code>。</li><li><code>window.event.cancelBubble = true </code>是用来阻止事件冒泡的,不是用来阻止默认行为的</li><li><code>event.preventDefault()</code> 是标准 DOM 事件模型中用来阻止默认行为的方法,但在 IE 浏览器中不支持,所以不是通用解决方案。</li><li><code>event.stopPropagation()</code> 同样是用来阻止事件冒泡的方法,这是标准 DOM 事件模型中的方法,不能阻止默认行为。</li></ul><h2 id="十二、node-js-模块加载机制" tabindex="-1">十二、Node.js 模块加载机制 <a class="header-anchor" href="#十二、node-js-模块加载机制" aria-label="Permalink to &quot;十二、Node.js 模块加载机制&quot;">​</a></h2><ol><li><p>首先查找核心模块(CORE MODULES) Node.js 会优先检查是否是内置的核心模块,如 fs、http 等。</p></li><li><p>其次查找当前目录下的模块文件(B 选项路径) 在当前目录下查找 othermodule.js 文件。</p></li><li><p>然后查找当前目录的 node_modules 目录(A 选项路径) 在当前目录的 node_modules 文件夹中查找 othermodule 模块。</p></li><li><p>最后逐级向上查找 node_modules 目录(D 选项路径) 如果在当前目录没找到,就会往上一级目录查找其 node_modules。</p></li></ol><p>这种查找顺序设计保证了:</p><ol><li>核心模块的加载优先级最高</li><li>本地模块优先于全局模块</li><li>遵循就近原则,从当前目录逐步向上查找</li><li>提高了模块的查找效率和可维护性</li></ol><h2 id="十三、js-变量提升" tabindex="-1">十三、js 变量提升 <a class="header-anchor" href="#十三、js-变量提升" aria-label="Permalink to &quot;十三、js 变量提升&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 答案：undefined</span></span></code></pre></div><p>上述代码等价于：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 变量提升，此时a是undefined</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这行代码永远不会执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="十四、选择题" tabindex="-1">十四、选择题 <a class="header-anchor" href="#十四、选择题" aria-label="Permalink to &quot;十四、选择题&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 0 1 3 1</span></span></code></pre></div><ul><li><p>0 &amp;&amp; 1 结果为 0： 因为&amp;&amp;运算符遇到假值就会立即返回,0 是假值,所以直接返回 0。</p></li><li><p>0 || 1 结果为 1： 因为||运算符遇到假值会继续往后找真值,0 是假值所以继续判断 1,1 是真值所以返回 1。</p></li><li><p>1 &amp;&amp; 3 结果为 3： 因为&amp;&amp;运算符在左侧为真值时会返回右侧操作数,1 是真值所以返回 3。</p></li><li><p>1 || 3 结果为 1： 因为||运算符遇到真值就会立即返回,1 是真值所以直接返回 1。</p></li></ul>`,114)]))}const E=s(t,[["render",n]]);export{c as __pageData,E as default};
