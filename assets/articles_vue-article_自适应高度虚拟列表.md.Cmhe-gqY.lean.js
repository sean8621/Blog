import{_ as m,c as h,o,m as n,t as u,O as d,D as p,a7 as x,a as f,a8 as I,F as _,C,b as H,a6 as v,H as c,w as b}from"./chunks/framework.BFVnfu0q.js";const T={props:{item:{default(){return{}},type:Object},index:Number},data(){return{}},mounted(){this.$emit("update-height",{height:this.$refs.node.getBoundingClientRect().height,index:this.index})}};function L(r,a,t,e,i,l){return o(),h("li",{key:t.item.brandId,style:d({height:`${t.item.height}px`,"line-height":`${t.item.height}px`}),ref:"node"},[n("div",null,[n("div",null,u(t.item.name),1)])],4)}const y=m(T,[["render",L]]),S={name:"App",components:{Item:y},data(){return{estimatedItemHeight:30,visibleCount:10,dataLength:200,startIndex:0,endIndex:10,scrollTop:0,scrollBarHeight:0,bufferItemCount:4,dataList:[],itemHeightCache:[],itemTopCache:[]}},computed:{visibleList(){return this.dataList.slice(this.startIndex,this.endIndex+this.bufferItemCount)}},watch:{dataList(){console.time("rerender"),setTimeout(()=>{console.timeEnd("rerender")},0)}},created(){this.dataList=this.getDataList(),this.generateEstimatedItemData()},mounted(){},methods:{generateEstimatedItemData(){const r=this.dataList.reduce((a,t,e)=>{this.itemHeightCache[e]=this.estimatedItemHeight;const i=this.estimatedItemHeight;return this.itemTopCache[e]=e===0?0:this.itemTopCache[e-1]+this.estimatedItemHeight,a+i},0);this.scrollBarHeight=r},updateItemHeight({index:r,height:a}){this.itemHeightCache[r]=a,this.scrollBarHeight=this.itemHeightCache.reduce((e,i)=>e+i,0);let t=[0];for(let e=1,i=this.itemHeightCache.length;e<i;e++)t[e]=this.itemTopCache[e-1]+this.itemHeightCache[e-1];this.itemTopCache=t},getDataList(){return[...Array(this.dataLength||0).keys()].map((a,t)=>({index:t,brandId:t+1,name:`第${t+1}项`,height:Math.floor(Math.max(Math.random()*30,5))*10}))},getStartIndex(r){let a=this.itemTopCache,t=-1,e=0,i=a.length-1,l=Math.floor((e+i)/2);for(;i-e>1;)if(r<a[l])i=l,l=Math.floor((e+i)/2);else if(r>a[l])e=l,l=Math.floor((e+i)/2);else return t=l,t;return t=e,t},onScroll(r){const a=r.target.scrollTop;let t=this.getStartIndex(a);t%2!==0?this.startIndex=t-1:this.startIndex=t,this.endIndex=this.startIndex+this.visibleCount,this.scrollTop=this.itemTopCache[this.startIndex]||0}}},k={id:"app"};function B(r,a,t,e,i,l){const g=p("Item");return o(),h("div",k,[x(n("input",{type:"text","onUpdate:modelValue":a[0]||(a[0]=s=>i.dataLength=s)},null,512),[[I,i.dataLength,void 0,{number:!0}]]),f("条 Height:"+u(i.scrollBarHeight)+" ",1),n("div",{class:"virtual-scroller",onScroll:a[1]||(a[1]=(...s)=>l.onScroll&&l.onScroll(...s)),style:{height:"600px"}},[n("div",{class:"phantom",style:d({height:i.scrollBarHeight+"px"})},[n("ul",{style:d({transform:`translate3d(0,${i.scrollTop}px,0)`})},[(o(!0),h(_,null,C(l.visibleList,s=>(o(),H(g,{item:s,index:s.index,key:s.brandId,onUpdateHeight:l.updateItemHeight},null,8,["item","index","onUpdateHeight"]))),128))],4)],4)],32)])}const w=m(S,[["render",B],["__scopeId","data-v-e8040410"]]),M=JSON.parse('{"title":"自适应高度虚拟列表","description":"","frontmatter":{},"headers":[],"relativePath":"articles/vue-article/自适应高度虚拟列表.md","filePath":"articles/vue-article/自适应高度虚拟列表.md"}'),D={name:"articles/vue-article/自适应高度虚拟列表.md"},V=Object.assign(D,{setup(r){return(a,t)=>{const e=p("preview");return o(),h("div",null,[t[0]||(t[0]=v('<h1 id="自适应高度虚拟列表" tabindex="-1">自适应高度虚拟列表 <a class="header-anchor" href="#自适应高度虚拟列表" aria-label="Permalink to &quot;自适应高度虚拟列表&quot;">​</a></h1><blockquote><p>虚拟列表大部分都是固定高度，因此思考不定高度的虚拟列表的实现方式。</p></blockquote><h2 id="实现方案" tabindex="-1">实现方案 <a class="header-anchor" href="#实现方案" aria-label="Permalink to &quot;实现方案&quot;">​</a></h2><ol><li>初始化</li></ol><ul><li>用估算高度初始化 itemHeightCache 和 itemTopCache。</li><li>计算总高度，设置滚动条高度。</li></ul><ol start="2"><li>滚动时定位可视区</li></ol><ul><li>监听滚动事件，获取 scrollTop。</li><li>通过二分查找在 itemTopCache 中定位当前可视区的起始索引（startIndex）。</li><li>计算可视区结束索引（endIndex = startIndex + visibleCount）。</li></ul><ol start="3"><li>渲染可见项</li></ol><ul><li>只渲染 startIndex ~ endIndex 区间的列表项。</li><li>用 transform: translate3d(0, scrollTop, 0) 将可见项定位到正确位置。</li></ul><ol start="4"><li>动态测量与修正</li></ol><ul><li>每个 item 渲染后，测量真实高度并通过事件上报。</li><li>若高度有变化，更新 itemHeightCache 和 itemTopCache，并重新计算 scrollBarHeight。</li><li>若当前滚动位置受影响，自动修正。</li></ul><h2 id="代码实现" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现" aria-label="Permalink to &quot;代码实现&quot;">​</a></h2>',12)),c(e,{"article-name":"vue-article","comp-name":"AutoSizeVirtualList"},{default:b(()=>[c(w)]),_:1})])}}});export{M as __pageData,V as default};
